== Declarative Deployment

ifndef::skipInstall[]
We recommend using a Minikube installation for this example. Please refer to the link:../../INSTALL.adoc#minikube[installation instructions] for details.

Let's now look, how we can get out https://github.com/k8spatterns/random-generator[random-generator] application from version 1 to version 2 with different update strategies.

First, install the application in version 1 by using the given deployment descriptor

[source, bash]
----
kubectl apply -f https://k8spatterns.io/DeclarativeDeployment/rolling-update.yml
----

This will deploy 3 replicas of the `random-generator` and configures a `RollingUpdate` update strategy (which would be also the default).

In order to be able to access our application, lets create a Service that is exposed with Minikube's internal loadbalancer:

[source, bash]
----
kubectl apply -f https://k8spatterns.io/DeclarativeDeployment/service.yml
----

The Service is of type `LoadBalancer`, so in order to access this service, you need to tell minikube to expose this at a random port. For doing this run the following command in the background, storing the URL that is printed out in a temporary file:

[source, bash]
----
minikube service random-app --url > /tmp/random-url.txt &
----

Let's start now in a dedicated terminal window a loop which constantly accesses our Service:

[source, bash]
----
url=$(cat /tmp/random-url.txt)
while true; do
  curl -s $url/info | jq '.version,.id'
  echo ===========================
  sleep 1
done
----

Now it's time to update to version 2.0.
As mentioned in the book, you can it in several ways.
Here we are using the easiest one and call `kubectl set image`:

[source, bash]
----
kubectl set image deployment random-generator random-generator=k8spatterns/random-generator:2.0
----

After you started the deployment you can do several things to monitor the update:

* Watch the terminal with the query loop we started. Do you see the change from version 1 to version 2 ? Are there any errors reported by curl ?
* Use `kubectl get pods -w` to watch how the Pods are coming down and up
* Use `kubectl rollout status` to see the status of the rollout.

When the update has finished, let's have some fun:

* Rollback the deployment with `kubectl rollout undo deploy/random-generator`
* Check the update history `kubectl rollout history deploy/random-generator`


Finally let's switch the update strategy to `Recreate`:

[source, bash]
----
kubectl replace -f https://k8spatterns.io/DeclarativeDeployment/recreate.yml

# Update to version 2.0 (or change to 1.0 when you have 2.0 running)
kubectl set image deployment random-generator random-generator=k8spatterns/random-generator:2.0
----

Can you spot the difference when doing the update, also with respect to the downtime ?

=== More Information

* https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/[Rolling Update]
* https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[Deployments]
* http://kubernetes.io/docs/user-guide/deploying-applications/[Deploying Applications]
* http://martinfowler.com/bliki/BlueGreenDeployment.html[Blue-Green Deployment]
* https://martinfowler.com/bliki/CanaryRelease.html[Canary Release]
* https://www.openshift.com/promotions/devops-with-openshift.html[DevOps with OpenShift]
